<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sports Supplements Information</title>
  <style>
    body { position: relative; min-height: 1500px; margin: 0; }
    .home-button { display: inline-block; }
    .home-button:hover { background-color: aquamarine; }

    /* Optional: make canvas fill the window. If you want fixed 700x700, remove this block and the JS resize code. */
    html, body { height: 100%; }
    #canvas { display: block; width: 100vw; height: 100vh; }

    .Bam {padding: 30px; background-color: yellowgreen;
     border: 3px solid #000;
  border-radius: 12px;
  font-size: 30px;
  font-weight: 700;
  color: #000;
  cursor: pointer;
  display: inline-block;
  text-align: center;

  /* Interaction effects */
  transition: transform 0.15s ease, 
              filter 0.15s ease, 
              background-color 0.15s ease;

  /* Do not allow highlighting text while clicking */
  user-select: none;
}

/* Hover state — looks interactive */
.Bam:hover {
  transform: scale(1.04);
  filter: brightness(0.95);
}

/* Active state — looks physically pressed */
.Bam:active {
  transform: scale(0.98);
  filter: brightness(0.9);
}

/* Keyboard navigation focus ring (optional but accessible) */
.Bam:focus-visible {
  outline: 4px solid #1e90ff;
  outline-offset: 2px;
}
#sor3
 {position: absolute; right: 200px; top: 30px;}

 .content-box {
  max-height: 0;
  overflow: hidden;
  background: #f9f9f9;
  padding: 0 20px;
  border-radius: 10px;
  position: absolute;
  top: 120px;
  left: -50px;
  width: 1200px;
  
  transition: max-height 0.3s ease, padding 0.3s ease;
}

.content-box.open {
  max-height: 500px;
  padding: 20px;
}

#supplement-button {
  position: relative;}

  </style>
</head>
<body>
<div id="supplement-button">
   <!--BCAAs-->
  <div class="section" style="position: absolute; left: 150px; top: 750px; font-size: 25px;">
    <div class="Bam">BCAAs</div>
    <div class="content-box"><p>BCAAs consist of only three amino acids<br><br>1. Leucine<br>2.Isoleucine<br>3.Valine<br>
    These three form the entire group called Branched-Chain Amino Acids. They're grouped together because each one has a branched side-chain structure and because they’re all essential (your body cannot make them), and they’re mainly metabolized inside skeletal muscle instead of the liver, which is unusual compared to other amino acids.
  </p></div>
  </div>
  <!--Creatine-->
  <div class="section" style="position: absolute; left: 420px; top: 750px; font-size: 25px;"> 
    <div class="Bam">Creatine</div>
    <div class="content-box" style="left: -320px;"><p>Creatine is a compound made from the amino acids arginine, glycine, and methionine, and its main job is to increase phosphocreatine stores inside your muscles so you can regenerate ATP faster; this leads to stronger lifts, more reps, better power output, faster recovery between sets, and easier muscle growth, and it also supports the brain by improving its energy availability, which helps with mental clarity and reduces fatigue; most people simply take 3–5 grams per day (lighter athletes closer to 3 g, heavier athletes closer to 5 g), and it’s 
      one of the safest and most effective supplements for strength, skeletal muscle performance, and cognitive function.</p></div>
  </div>
  <!--Glutamine-->
  <div class="section" style="position: absolute; left: 700px; top: 750px; font-size: 25px;">
    <div class="Bam">Glutamine</div>
    <div class="content-box" style="left: -600px;"><p>Glutamine is an amino acid that your body uses for immune function, gut lining repair, nitrogen transport, and recovery.
       It helps maintain the intestinal barrier, supports immune cells during stress or hard training, and serves as a fuel source for rapidly dividing cells, but for muscle growth it is not very effective because healthy muscle already has plenty of glutamine, so most athletes use it mainly for gut health and immune support rather than strength or hypertrophy. Typical doses range from 5–10 grams per day, usually around workouts or before sleep.</p></div>
  </div>
  <!--Citrulline Malate-->
  <div class="section" style="position: absolute; left: 1000px; top: 750px; font-size: 25px;">
    <div class="Bam">Citrulline Malate</div>
    <div class="content-box" style="left: -900px;"><p> Citrulline Malate is a combination of the amino acid L-citrulline and malic acid, and its main job is to increase nitric oxide production by raising blood arginine levels, which improves blood flow, boosts muscle pumps, enhances nutrient delivery, and delays fatigue; it also assists in the removal of ammonia and lactic acid from working muscles, helping you maintain power during high-intensity sets, and malate supports the Krebs cycle for extra endurance energy, making it one of the best supplements for pump,
       performance, and training volume. The standard effective dose is 6–8 grams about 45 minutes before training. </p></div>
  </div>
   
  
  <!--source-->
  <button id="sor3" onclick="window.open('source3.html','_blank')">Source
</button>






  <canvas id="canvas" width="700" height="700"></canvas>

  <h1 style="position: absolute; left: 50%; transform: translateX(-50%); top: 150px;
             font-size: 60px; white-space: nowrap;">
    Sports Supplements Comprehension
  </h1>

  <!--Home button-->
      <button class="home-button"
        onclick="window.location.href='https://musclysoftwareengineer.github.io/Supplements/'"
        style="position: absolute; top: 30px; right: 100px;">
  Home
</button>
  <script src="MYjs/gsap.min.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // ====== If you want the canvas to fill the page, keep this; otherwise remove these two lines ======
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    resizeCanvas(); window.addEventListener("resize", resizeCanvas);
    // ==================================================================================================

    // time
    
    const EPS = 1.5;            // "near enough" to the startX to stop

    // Optional rounded corner radius for the rectangles (increase to "increase radius" of corners)
    const cornerR = 0; // try 20, 40, etc.

    // draw rounded rectangles 
    function fillRoundRect(x, y, w, h, r) {
      if (!r) {
        ctx.fillRect(x, y, w, h);
        return;
      }
      const rr = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
      ctx.fill();
    }

    // --- Boxes (center-based for easy rotation) ---
    //  constant half-width (w/2) for edge collisions so they truly reach the canvas edge.
    const boxes = [
       
      {
        // Red box: original top-left was (10,10) with size 400x400 -> center at (210, 210)
        x: 210, y: 210, w: 400, h: 400,
        vx: 120, color: "rgb(255 0 0 / 50%)",
        angle: 0, omega: Math.PI / 6,
        startX: 210, lastX: 210,
        state: "moving", pauseUntil: 0,
        moveTime: 0, pauseArmed: false,
        savedVx: 0, savedOmega: 0,
        leftStart: false,
        moveWindow: 15.0,   // seconds this box moves before next pause is armed
        pauseMs: 3000,      // milliseconds this box pauses at startX

      },
      {
        // Blue box: original top-left was (200,200) with size 400x400 -> center at (400, 400)
        x: 400, y: 400, w: 400, h: 400,
        vx: -160, color: "rgb(0 0 200 / 50%)",
        angle: 0, omega: -Math.PI / 4,
        startX: 400, lastX: 400,
        state: "moving", pauseUntil: 0,
        moveTime: 0, pauseArmed: false,
        savedVx: 0, savedOmega: 0,
        leftStart: false,
        moveWindow: 15.,   // seconds this box moves before next pause is armed
        pauseMs: 3500,      // milliseconds this box pauses at startX

      }
    ];

    function crossedStart(b) {
      return (b.lastX - b.startX) * (b.x - b.startX) <= 0 && Math.abs(b.x - b.lastX) > 0.001;
    }

    function maybeArmPause(b) {
      if (!b.pauseArmed && b.moveTime >= b.moveWindow) {
  b.pauseArmed = true;
}

    }

    function maybeStartPauseAtStart(b, now) {
      const near = Math.abs(b.x - b.startX) <= EPS;
      if (b.pauseArmed && b.leftStart && (crossedStart(b) || near)) {
        b.state = "pausing";
        b.pauseUntil = now + b.pauseMs;


        // Save current motion to resume later in the SAME direction
        b.savedVx = b.vx;
        b.savedOmega = b.omega;

        // Freeze and snap to exact start position
        b.vx = 0;
        b.omega = 0;
        b.x = b.startX;

        // Reset cycle flags
        b.moveTime = 0;
        b.pauseArmed = false;
        b.leftStart = false;
      }
    }

    let lastTime = performance.now();

    function update(dt, now) {
      for (const b of boxes) {
        if (b.state === "pausing") {
          if (now >= b.pauseUntil) {
            // Resume with same direction and spin
            b.vx = b.savedVx || b.vx;
            b.omega = b.savedOmega || b.omega;
            b.state = "moving";
            b.moveTime = 0;
            b.lastX = b.x;
          }
          continue;
        }

        // MOVING
        b.moveTime += dt;
        maybeArmPause(b);

        b.lastX = b.x;

        // Integrate motion
        b.x += b.vx * dt;
        b.angle += b.omega * dt;

        // Mark that we've left the start at least once in this cycle
        if (!b.leftStart && Math.abs(b.x - b.startX) > EPS) b.leftStart = true;

        // --- Edge collisions (constant half-width so boxes "reach the end") ---
        const halfW = b.w / 2;
        if (b.x - halfW < 0) { b.x = halfW; b.vx *= -1; }
        else if (b.x + halfW > canvas.width) { b.x = canvas.width - halfW; b.vx *= -1; }

        // If a pause is armed, stop the next time we return to startX
        maybeStartPauseAtStart(b, now);
      }
    }

    function drawBox(b) {
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(b.angle);
      ctx.fillStyle = b.color;
      // draw from center
      fillRoundRect(-b.w / 2, -b.h / 2, b.w, b.h, cornerR);
      ctx.restore();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const b of boxes) drawBox(b);
    }

    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;
      update(dt, now);
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) lastTime = performance.now();
    });
    
    // buttons
    document.querySelectorAll('.Bam').forEach(btn => {
  btn.addEventListener('click', () => {
    
    const currentContent = btn.nextElementSibling;

    // Close other boxes
    document.querySelectorAll('.content-box.open').forEach(box => {
      if (box !== currentContent) {
        box.classList.remove('open');
      }
    });

    // Toggle only this one
    currentContent.classList.toggle('open');
  });
});



  </script>
</body>
</html>
